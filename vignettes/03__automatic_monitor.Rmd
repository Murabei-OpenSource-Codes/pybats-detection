---
title: "Automatic Monitoring"
author: "Andr√© Menezes"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

# Automatic Monitoring

The automatic monitoring method sequentially evaluate the forecasting activity to
detect breakdowns, based on Bayes factor for two models $M_0$ versus $M_1$ with 
same mathematical structure, differing only through the values for $\boldsymbol{\theta}_t$ or simply the discount factors. Let $M_0$ be a standard DLM
without intervention and $M_1$ and alternative model that is introduced to provide
assessment of $M_0$ by comparison. The Bayes' factor for the observed value $y_t$
is given by

$$
H_t = p_0(y_t \vert D_{t-1}) / p_1(y_t \vert D_{t-1}),
$$
where $p_0$ and $p_1$ are the predictive densities at time $t$ for $M_0$ and 
$M_1$.If $H_t$ is small then the $M_1$ model is preferred. For $k=1, \dots, t$ last consecutive observations $y_t, y_{t-1}, y_{t-k+1}$
the local Bayes factor is given by 
$$
H_t(k) = \prod_{r=t-k+1}^t H_r = \frac{p_0 (y_t, y_{t-1}, \dots, y_{t-k+1})}{p_1 (y_t, y_{t-1}, \dots, y_{t-k+1})}.
$$
and the cumulative Bayes factor $(L_t)$ is
$$
L_t = \min_{1\leq k \leq t} H_t(k), \\
$$
the minimum at time $t$ is taken at $k=l_t$, with $L_t = H_t(l_t)$ and $l_t$ 
being a integer given by
$$
l_t = (1+l_{t-1}) I(L_{t-1} < 1) + I(L_{t-1} \geq 1),
$$
where $I(\cdot)$ is a indicator function. 

Basically, $H_t$ is initially used to 
indicate if $y_t$ is a outlier when $H_t < \tau$ (which represent preference for $M_1$).
However a small Bayes factor may indicate the start of a regime change, in this case
we need to accumulate evidences. For this $L_t$ and $l_t$ are used. The automatic
detection is done following the steps

* If $H_t \leq \tau$, then $y_t$ is a outlier and is omitted from the analysis.
* If $H_t > \tau$, we must look at $L_t$ for cumulative evidence against $M_0$. 
    + If $L_t < \tau$ or $l_t > 2$ then a parametric chance is detected $M_1$ is adopted.

It is also possible to consider two alternative models $M_1$ and $M_2$, this is useful
for identification of outliers/regime change in two directions. 

## Telephone Calls 

To illustrate the performance of the monitoring we'll use the monthly average daily 
telephone calls to Cincinnati directory assistance time series, from January 1962 to December 1973. The data is given bellow. 

```{python load-telephone_calls}
calls = load_telephone_calls()
```

```{r plot-calls, echo=FALSE, fig.cap="Average daily telephone calls to Cincinnati directory assistance", fig.dim=c(16,9), warnings = FALSE, out.width = "90%"}
df_calls <- py$calls %>% 
  mutate(time = as.Date(time))
p_calls <- ggplot(df_calls, aes(x = time, y = average_daily_calls)) +
  geom_point(size = 3) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") +
  labs(x = "Month/Year", y = "Sales") + 
  theme(axis.text=element_text(size=20), 
  axis.title=element_text(size=20))
p_calls
```

The automatic monitoring can be done 
using the `Monitoring` class on objects of class `pybats.dglm.dlm`.

```{python fit-level-change-data-monitoring-class}
a = np.array([300, 0])
R = np.eye(2)
np.fill_diagonal(R, val=[100])
mod = dlm(a, R, ntrend=2, deltrend=0.95)

# Fit with monitoring
monitor = Monitoring(mod=mod, prior_length = 20, bilateral = True, 
smooth = True, interval = True, level = 0.05)
```

```{python fit-level-change-data-monitoring-class-telephone, echo=FALSE}
# Fit with monitoring
smooth = Smoothing(mod=mod)
smooth_fit = smooth.fit(y=calls["average_daily_calls"])
filter_df = smooth_fit.get('filter').get('predictive')
```

where 


* `mod`: A DLM from `pybats.dglm.dlm`; 
* `bilateral`: A Boolean indicating if a bilateral monitoring should be performed
* `prior_length`: A integer that indicates the number of prior observations without monitoring; 
* `smooth`: a Boolean indicating if smooth moments should be computed; 
* `interval`: a Boolean indicating if credible intervals should be calculated; 
* `level`: A number between 0 and 1 indicating the probability level of the
            credible interval.

The `.fit` method will perform the monitoring steps by the following arguments


* `h`: Value of change in the scale or location of the predictive  distribution.
* `tau`: The threshold to compare de Bayes factor.
* `change`: is a list of values to increase the uncertainty on state space parameter by multiplying the prior covariance matrix, $\mathbf{R}_t$, when the monitor detects potential outlier or parametric change. If length of change var is different to number of model parameters, then the covariance matrix is multiplied by the first value in the List. The covariance terms are multiplied by the minimum value in `change var`.

By default we'll use `tau=0.135` and `h=4`. For more details see West and Harrison.
A summary for the fit will be automatically printed, information regarding what was detected (outlier or parametric change), values for $H_t$, $L_t$ and $l_t$. The
result will be a dictionary with same structure presented in the smoothing section

```{python fit-level-change-data-monitoring-fit, results='hide'}
fit_monitor = monitor.fit(y=calls["average_daily_calls"], 
h=4, tau=0.135, change_var=[10, 2])
forecast_df = fit_monitor.get("filter").get("predictive")
```


\tiny
```{python fit-level-change-data-monitoring-fit-output, echo=FALSE}
fit_monitor = monitor.fit(y=calls["average_daily_calls"], 
h=4, tau=0.135, change_var=[10, 2])
forecast_df = fit_monitor.get("filter").get("predictive")
```
\normalsize

```{r plot-fit-cp6-filter-monitor, echo=FALSE, fig.cap="Mean response for Filtered predictive distribution with $95\\%$ credible interval with and without monitor", fig.dim=c(16,9), warnings = FALSE, out.width = "90%"}
df_calls = py$calls %>% mutate(time = as.Date(time))
data_predictive = py$forecast_df 
data_filter = py$filter_df 
data_predictive$time = df_calls$time
data_filter$time = df_calls$time

p1 = data_predictive %>%
  ggplot(aes(x = time, y = y)) +
  geom_point(size = 3) +
  geom_line(aes(y = f), size = 0.8) +
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
              alpha=.25, colour = 'grey40') +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") +
  theme(legend.position = "top") +
  xlab('Month/Year') + ylab('Sales') + 
  theme(axis.text=element_text(size=20), 
  axis.title=element_text(size=20)) +
  colorspace::scale_color_discrete_divergingx()

p2 = data_filter %>%
  ggplot(aes(x = time, y = y)) +
  geom_point(size = 3) +
  geom_line(aes(y = f), size = 0.8) +
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
              alpha=.25, colour = 'grey40') +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") +
  theme(legend.position = "top") +
  xlab('Month/Year') + ylab('Sales') + 
  theme(axis.text=element_text(size=20), 
  axis.title=element_text(size=20)) +
  colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p
```

## Simulated examples

### Level Change

```{python simulating-level-change-data, engine = "python", results='hide'}
np.random.seed(66)
rdlm = RandomDLM(n=50, V=0.1, W=0.005)
df_simulated = rdlm.level(
    start_level=100,
    dict_shift={"t": [40],
                "level_mean_shift": [1],
                "level_var_shift": [1]})
df_simulated.loc[40:50, "y"] = 101 + np.random.normal(0, 0.2, 10)
```

```{r plot-level-change-data, echo=FALSE, fig.cap="Simulated data with level change", fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
ggplot(py$df_simulated, aes(x = t, y = y)) +
  geom_point(size=3) + geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = scales::pretty_breaks(10)) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=25), 
  axis.title=element_text(size=25)) +
  colorspace::scale_color_discrete_divergingx()

```


```{python fit-level-change-data, message=FALSE, echo=FALSE, results='hide'}
a = np.array([100])
R = np.eye(1)
R[[0]] = 100
mod = dlm(a, R, ntrend=1, deltrend=0.9)

# Fit without monitoring
fit_without_monitor = Smoothing(mod=mod).fit(y=df_simulated["y"])
df_res = fit_without_monitor.get("filter").get("predictive")

# Fit with monitoring
monitor = Monitoring(mod=mod, bilateral=False)
fit_monitor = monitor.fit(y=df_simulated["y"], h=3, tau=0.135, 
change_var=[100])
df_tmp = fit_monitor.get("filter").get("predictive")
```

```{python fit-level-change-data-organize, echo=FALSE}
df_res["monitor"] = False
df_tmp["monitor"] = True
cols_ord = ["t", "y", "f", "q", "ci_lower", "ci_upper", "monitor", "e",
            "H", "L", "l"]
df_res = pd.concat([df_res, df_tmp[cols_ord]]).reset_index(drop=True)
```

```{r plot-fit-level-change-data, echo=FALSE, fig.cap="Fit for simulated data with level change", fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
p1 = py$df_res |> filter(t > 5, monitor == TRUE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()


p2 = py$df_res |> filter(t > 5, monitor == FALSE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p
```


### Outliers

```{python simulating-outliers-data}
np.random.seed(66)
rdlm = RandomDLM(n=50, V=0.1, W=0.01)
df_simulated = rdlm.level(
    start_level=100,
    dict_shift={"t": [10, 11, 20, 21, 30, 31, 40, 41],
                "level_mean_shift": [2, -2, 3, -3, 3.4, -3.4, 3, -3],
                "level_var_shift": [1, 1, 1, 1, 1, 1, 1, 1]})
```

```{r plot-outliers-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
ggplot(py$df_simulated, aes(x = t, y = y)) +
  geom_point() +
  geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = scales::pretty_breaks(20)) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=25), 
  axis.title=element_text(size=25)) +
  colorspace::scale_color_discrete_divergingx()
```

```{python fit-outliers-data, echo=FALSE, message=FALSE, results='hide'}
a = np.array([100])
R = np.eye(1)
R[[0]] = 100
mod = dlm(a, R, ntrend=1, deltrend=0.9)

# Fit without monitoring
fit_without_monitor = Smoothing(mod=mod).fit(y=df_simulated["y"])
df_res = fit_without_monitor.get("filter").get("predictive")

# Fit with monitoring
monitor = Monitoring(mod=mod, bilateral=False)
fit_monitor = monitor.fit(y=df_simulated["y"], h=4, tau=0.135, 
change_var=[100])
df_tmp = fit_monitor.get("filter").get("predictive")
```

```{python fit-outliers-data-organize, echo=FALSE}
df_res["monitor"] = False
df_tmp["monitor"] = True

# Append
cols_ord = ["t", "monitor", "y", "f", "q", "ci_lower", "ci_upper"]
df_res = pd.concat([df_res[cols_ord], df_tmp[cols_ord]]).reset_index(drop=True)
```

```{r plot-fit-outliers-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
p1 = py$df_res |> filter(t > 5, monitor == TRUE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()


p2 = py$df_res |> filter(t > 5, monitor == FALSE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p
```


### Outlier and Level Change 

```{python simulating-outlier-level-change-data}
np.random.seed(66)
rdlm = RandomDLM(n=50, V=0.1, W=0.01)
df_simulated = rdlm.level(
    start_level=100,
    dict_shift={"t": [20, 21, 40],
                "level_mean_shift": [3, -3, 10],
                "level_var_shift": [1, 1, 1]})
```

```{r plot-outlier-level-change-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
ggplot(py$df_simulated, aes(x = t, y = y)) +
  geom_point() + geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = scales::pretty_breaks(20)) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=25), 
  axis.title=element_text(size=25)) +
  colorspace::scale_color_discrete_divergingx()
```


```{python fit-outlier-level-change-data, echo=FALSE, message=FALSE, results='hide'}
a = np.array([100])
R = np.eye(1)
R[[0]] = 100
mod = dlm(a, R, ntrend=1, deltrend=0.9)

# Fit without monitoring
fit_without_monitor = Smoothing(mod=mod).fit(y=df_simulated["y"])
df_res = fit_without_monitor.get("filter").get("predictive")

# Fit with monitoring
monitor = Monitoring(mod=mod, bilateral=False)
fit_monitor = monitor.fit(y=df_simulated["y"], h=4, tau=0.135, change_var=[10])
df_tmp = fit_monitor.get("filter").get("predictive")
```

```{python fit-outlier-level-change-data-organize, echo=FALSE}
df_res["monitor"] = False
df_tmp["monitor"] = True

# Append
cols_ord = ["t", "monitor", "y", "f", "q", "ci_lower", "ci_upper"]
df_res = pd.concat([df_res[cols_ord], df_tmp[cols_ord]]).reset_index(drop=True)
```


```{r plot-fit-outlier-level-change-data, echo=FALSE, message=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
p1 = py$df_res |> filter(t > 5, monitor == TRUE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()


p2 = py$df_res |> filter(t > 5, monitor == FALSE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p
```


### Outlier and Two Level Change

```{python simulating-outlier-two-level-change-data}
np.random.seed(66)
rdlm = RandomDLM(n=70, V=1, W=0.01)
df_simulated = rdlm.level(
    start_level=100,
    dict_shift={"t": [20, 21, 40, 60],
                "level_mean_shift": [5, -5, 10, 10],
                "level_var_shift": [1, 1, 1, 1]})
```

```{r plot-outlier-two-level-change-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
ggplot(py$df_simulated, aes(x = t, y = y)) +
  geom_point() + geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = scales::pretty_breaks(20)) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=25), 
  axis.title=element_text(size=25)) +
  colorspace::scale_color_discrete_divergingx()
```


```{python fit-outlier-two-level-change-data, echo=FALSE, message=FALSE, results='hide'}
a = np.array([100])
R = np.eye(1)
R[[0]] = 100
mod = dlm(a, R, ntrend=1, deltrend=0.9)

# Fit without monitoring
fit_without_monitor = Smoothing(mod=mod).fit(y=df_simulated["y"])
df_res = fit_without_monitor.get("filter").get("predictive")

# Fit with monitoring
monitor = Monitoring(mod=mod, bilateral=False)
fit_monitor = monitor.fit(y=df_simulated["y"], h=4, tau=0.135, change_var=[10])
df_tmp = fit_monitor.get("filter").get("predictive")

```

```{python fit-outlier-two-level-change-data-organize, echo=FALSE}
df_res["monitor"] = False
df_tmp["monitor"] = True

# Append
cols_ord = ["t", "monitor", "y", "f", "q", "ci_lower", "ci_upper"]
df_res = pd.concat([df_res, df_tmp[cols_ord]]).reset_index(drop=True)
```

```{r plot-fit-outlier-two-level-change-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
p1 = py$df_res |> filter(t > 5, monitor == TRUE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()


p2 = py$df_res |> filter(t > 5, monitor == FALSE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p

```

### Bilateral Level Change

```{python simulating-bilateral-level-change-data}
np.random.seed(66)
y1 = np.random.normal(loc=100, scale=0.8, size=40)
y2 = np.random.normal(loc=104, scale=0.5, size=20)
y3 = np.random.normal(loc=98, scale=0.5, size=20)
y = np.concatenate([y1, y2, y3])
t = np.arange(0, len(y)) + 1
df_simulated = pd.DataFrame({"t": t, "y": y})
```

```{r plot-bilateral-level-change-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
ggplot(py$df_simulated, aes(x = t, y = y)) +
  geom_point() +
  geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = scales::pretty_breaks(20)) +
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=25), 
  axis.title=element_text(size=25)) +
  colorspace::scale_color_discrete_divergingx()
```

```{python fit-bilateral-level-change-data, echo=FALSE, message=FALSE, results='hide'}
a = np.array([100])
R = np.eye(1)
R[[0]] = 100
mod = dlm(a, R, ntrend=1, deltrend=0.80)

# Fit without monitoring
fit_without_monitor = Smoothing(mod=mod).fit(y=df_simulated["y"])
df_res = fit_without_monitor.get("filter").get("predictive")

# Fit with monitoring
monitor = Monitoring(mod=mod, bilateral=True)
fit_monitor = monitor.fit(y=df_simulated["y"], h=4, tau=0.135, change_var=[100])
df_tmp = fit_monitor.get("filter").get("predictive")
```

```{python fit-bilateral-level-change-data-organize, echo=FALSE}
df_res["monitor"] = False
df_tmp["monitor"] = True

# Append
cols_ord = ["t", "y", "f", "q", "ci_lower", "ci_upper", "monitor"]
df_res = pd.concat([df_res[cols_ord], df_tmp[cols_ord]]).reset_index(drop=True)
```

```{r plot-bilateral-fit-level-change-data, echo=FALSE, fig.dim=c(16,9), warnings = FALSE, out.width = "100%"}
p1 = py$df_res |> filter(t > 5, monitor == TRUE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()


p2 = py$df_res |> filter(t > 5, monitor == FALSE) |>
  ggplot(aes(x = t)) +
    geom_point(aes(y = y), size = 2) + geom_line(aes(y = f)) +
    geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), 
                alpha=.25, colour = 'grey40') +
    geom_vline(xintercept = 41, linetype='dashed') + 
    scale_x_continuous(breaks = scales::pretty_breaks(10)) +
    scale_y_continuous(breaks = scales::pretty_breaks(10)) +
    theme(axis.text=element_text(size=20), 
    axis.title=element_text(size=20)) +
    colorspace::scale_color_discrete_divergingx()

grid_p = plot_grid(p1, p2, labels=c('With Monitor', 'Without Monitor'), ncol=1, 
                   label_size = 30)
grid_p
```

