---
title: "Simulated examples for Smoothing class"
author: "Eduardo Gabriel"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

# Smoothing

A brief introduction of the Smoothing class in a simulated example. A time series $\mathbf{Y} = (y_1, \dots, y_T)$ was generated using the 
$RandomDLM$ class which has the arguments (n, V, W): the number of observations, observational variance and state vector variance. This class has three methods that simulate data using different mechanisms:

* $.level$: dynamic level model; 
* $.growth$: dynamic growth model;
* $.level\_with\_covariates$: dynamic level model where $Y$ is simulated given $X$, a matrix of fixed covariates. 

For now, we stick with $.level$, simulating $n=100$ observations with both observational and state vector variance equals to one $1$, the starting level is set to $100$. The simulated data is plotted below. 

```{python}
# Generating level data model
np.random.seed(66)
rdlm = RandomDLM(n=100, V=1, W=1)
df_simulated = rdlm.level(
    start_level=100,
    dict_shift={})
y = df_simulated["y"]
```

```{r, message = FALSE, fig.cap="Simulated data", fig.dim=c(16,9), warnings = FALSE, echo=FALSE, out.width = "90%"}
df = py$df_simulated
df %>% ggplot(aes(x = t, y = y)) +
  geom_point(size = 3) + ylab(' ') + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=20))
```
The Smoothing class allows you to perform a retrospective analysis for $\mathbf{Y}$, obtaining the distribution of $(\boldsymbol{\theta}_{T-k} \vert D_T)$, for $k \geq 1$, the k-step smoothed distribution for the state vector at time $T$, which is analogous to the k-step ahead forecast distribution $(\boldsymbol{\theta}_{t+k}\vert D_t)$. 

To use Smoothing, first it is necessary to define the model components with prior values, which is done with the $dlm$ class available in the $pybats$ package. In this case, it was considered a DLM with level and growth. The prior vector and covariances are defined by $\mathbf{a}$ and $\mathbf{R}$. Lastly, the discount factor denoted by $deltrend$ is a constant in the interval (0, 1), it's used to coordinate the 
adaptive capacity of predictions with increasing variance of model components. 

Given this, the method $.fit$ will initialize the model and the loop forecast, observe and update begin. The prior and posterior moments $(\mathbf{a}_t, \mathbf{m}_t, \mathbf{C}_t, \mathbf{R}_t)$ will be computed for all $t$ and saved.  Subsequently, these moments will be used to obtain the moments for $(\boldsymbol{\theta}_{T-k} \vert D_T)$, recursively with $k \geq 1$, and denoted by $(\mathbf{a}_T(-k), \mathbf{m}_T(-k), \mathbf{C}_T(-k), \mathbf{R}_T(-k))$.

```{python, "Define model"}
# Define model components
a = np.array([100, 0])
R = np.eye(2)
np.fill_diagonal(R, val=1)
mod = dlm(a, R, ntrend=2, deltrend=.95)

# Fit with monitoring
smooth = Smoothing(mod=mod)
smooth_fit = smooth.fit(y=y)
```

This will return a dictionary with 
moments for: smoothed and filtered predictive distributions and for the posterior distributions of the model components. Below the results for the predictive distributions 

## Smoothed Predictive
```{python, echo=FALSE}
tab1 = smooth_fit.get('smooth').get('predictive').round(2).head()
tab2 = smooth_fit.get('smooth').get('posterior').round(2).head()
tab3 = smooth_fit.get('filter').get('predictive').round(2).head()
tab4 = smooth_fit.get('filter').get('posterior').round(2).head()
```

The results for the smoothed predictive distribution consists of: $f_T(-k), q_T(-k)$ and the bounds for the credibility interval ($ci\_lower, ci\_upper$). Given by

$$
f_T(-k) = \mathbf{F}^{'} \mathbf{a}_T(-k), \quad \quad q_T(-k) = \mathbf{F}^{'} \mathbf{R}_T(-k) \mathbf{F}
$$
The credibility interval is is obtained from the corresponding smoothed distributions for the mean response of the series. Since $V$ is considered unknown, then 

$$
(\mu_T(-k) \vert D_T) \sim T_{n_t}[f_T(-k), q_T(-k)]
$$
For this simulated example, the results for the smoothed predictive distribution for the mean response are 
```{python, results='hide'}
smooth_fit.get('smooth').get('predictive').round(2).head()
```

```{r, echo=FALSE, results='asis'}
tab1 = py$tab1
tab2 = py$tab2
tab3 = py$tab3
tab4 = py$tab4

kable(tab1, caption = 'Smothed predictive distribution results')
```

```{python, echo=FALSE}
# Fit without monitoring
predictive_filter_df = smooth_fit.get('filter').get('predictive')
predictive_smooth_df = smooth_fit.get('smooth').get('predictive')
posteriori_smooth_df = smooth_fit.get('smooth').get('posterior')
posteriori_filter_df = smooth_fit.get('filter').get('posterior')
```

```{python, echo=FALSE}
predictive_filter_df['y'] = y.copy()
predictive_smooth_df['y'] = y.copy()
```

Plotting the filtered vs smoothed predictive distributions results is possible to see difference, primarily in the length of the credibility interval. 

```{r, echo=FALSE, fig.dim=c(16, 9), out.width = "90%", "plots for smooth simulated example"}
predictive_filter_df = py$predictive_filter_df 
predictive_smooth_df = py$predictive_smooth_df 
posteriori_smooth_df = py$posteriori_smooth_df 
posteriori_filter_df = py$posteriori_filter_df 

p1 = predictive_filter_df %>% 
  ggplot(aes(x = t)) + geom_point(aes(y = y)) + 
  geom_line(aes(y = f), colour = 'dodgerblue4') + 
  ylab(' ') + xlab('t') + 
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), alpha=0.25, colour = 'grey40') + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=20), axis.title=element_text(size=20)) +
  ggtitle('Filter')

p2 = predictive_smooth_df %>% 
  ggplot(aes(x = t)) + geom_point(aes(y = y)) + 
  geom_line(aes(y = fk), colour = 'dodgerblue4') + 
  ylab(' ') + xlab('t') + 
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), alpha=0.25, colour = 'grey40') + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_continuous(breaks = scales::pretty_breaks(10)) +
  theme(axis.text=element_text(size=20), axis.title=element_text(size=20)) +
  ggtitle('Smooth')

plot_grid(p1, p2, ncol=2)
```

## Smoothe Posterior
```{python, results='hide'}
smooth_fit.get('smooth').get('posterior').round(2).head()
```

```{r, message = FALSE, warnings = FALSE, echo=FALSE}
posterior_plot = function(data){
  p = data %>% ggplot(aes(x = t)) +
    geom_line(aes(y = mean), colour = 'dodgerblue4') + ylab(' ') +
    geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper),
                alpha = 0.25,
                colour = 'grey40') +
    scale_y_continuous(breaks = scales::pretty_breaks(10))
  return(p)
}

p1 = posteriori_filter_df %>% filter(parameter == 'theta_1') %>% 
  posterior_plot + ggtitle('Filter', subtitle = 'Component: Level')
p2 = posteriori_filter_df %>% filter(parameter == 'theta_2') %>% 
  posterior_plot + ggtitle('Filter', subtitle = 'Component: Growth') + 
  ylim(-2.0, 2.0)
p3 = posteriori_smooth_df %>% filter(parameter == 'theta_1') %>% 
  posterior_plot + ggtitle('Smooth', subtitle = 'Component: Level') 
p4 = posteriori_smooth_df %>% filter(parameter == 'theta_2') %>% 
  posterior_plot + ggtitle('Smooth', subtitle = 'Component: Growth') + 
  ylim(-2.0, 2.0)
plot_grid(p1, p2, p3, p4)
```

## Aplication: AirPassangers dataset

Below is a practical example with the classic Box & Jenkins airline data, 
Monthly totals of international airline passengers (1949 to 1960), 
using a normal DLM with three main components: Trend, Growth and Seasonality. 
```{r echo=FALSE}
data(AirPassengers)
data_df = data.frame(value=AirPassengers)
data_df$t = seq(as.Date("1949-01-01"), 
                as.Date("1960-12-01"),  by="1 month")
data_df %>% ggplot(aes(x = t, y = value)) + 
  geom_line() + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") +
  labs(x = "Month/Year", y = "Sales")
```
```{python, include=FALSE}
# Data Loading
data_df = r.data_df
```
Here it was specified a yearly seasonal effect of period 12, with the first two 
harmonics. The discount factor for the seasonal components is 0.98. 
```{python}
a = np.array([112, 0, 1, -1, 1, -1])
R = np.eye(6)
np.fill_diagonal(R, val=1)
mod = dlm(a, R, ntrend=2, deltrend=.95, delseas=.98,
          seasPeriods=[12], seasHarmComponents=[[1, 2]])
```

```{python, include=FALSE}
y = data_df['value']

# Fit without monitoring
smooth = Smoothing(mod=mod)
smooth_fit = smooth.fit(y=y)

predictive_filter_df = smooth_fit.get('filter').get('predictive')
predictive_smooth_df = smooth_fit.get('smooth').get('predictive')
posteriori_smooth_df = smooth_fit.get('smooth').get('posterior')

predictive_filter_df['y'] = y.copy()
predictive_smooth_df['y'] = y.copy()
```

```{python, include=FALSE, "Compute seasonality components sum mean"}
ak = smooth._dict_smooth_parms.get('ak')
seasonality_block = [ak[-i][2:] for i in range(1, len(ak)+1)]
ones_vec = mod.F[2:]

seasonality_mean = [(ones_vec.T @ seasonality_block[i])[0][0] for i in range(len(ak))]
```

```{python, include=FALSE, "Compute seasonality component sum variance"}
Rk = smooth._dict_smooth_parms.get('Rk')
seasonality_block = [Rk[-i][2:, 2:] for i in range(1, len(Rk)+1)]

seasonality_variance = [(ones_vec.T @ seasonality_block[i] @ ones_vec)[0][0] for i in range(len(Rk))]

seasonality_posteriori_smooth_df = pd.DataFrame({'parameter': 'theta_7', 
'mean': seasonality_mean, 'variance': seasonality_variance, 
't': range(1, 145)}) 

seasonality_posteriori_smooth_df['ci_lower'] = stats.t.ppf(
  q=.025, df=seasonality_posteriori_smooth_df["t"].values[-1] + 1,
  loc=seasonality_posteriori_smooth_df["mean"].values,
  scale=np.sqrt(seasonality_posteriori_smooth_df["variance"].values))

seasonality_posteriori_smooth_df['ci_upper'] = stats.t.ppf(
  q=.975, df=seasonality_posteriori_smooth_df["t"].values[-1] + 1,
  loc=seasonality_posteriori_smooth_df["mean"].values,
  scale=np.sqrt(seasonality_posteriori_smooth_df["variance"].values))

posteriori_smooth_df = pd.concat([posteriori_smooth_df, seasonality_posteriori_smooth_df])    
```

```{r, echo=FALSE, "plots for airpassangers example"}
predictive_filter_df = py$predictive_filter_df 
predictive_smooth_df = py$predictive_smooth_df 
posteriori_smooth_df = py$posteriori_smooth_df 

predictive_filter_df$t = data_df$t
predictive_smooth_df$t = data_df$t
posteriori_smooth_df$t = data_df$t

p1 = predictive_filter_df %>% 
  ggplot(aes(x = t)) + geom_point(aes(y = y)) + 
  geom_line(aes(y = f), colour = 'dodgerblue4') + 
  ylab(' ') + xlab('Month/Year') + 
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), alpha=0.25, colour = 'grey40') + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") + 
  ggtitle('Filter')

p2 = predictive_smooth_df %>% 
  ggplot(aes(x = t)) + geom_point(aes(y = y)) + 
  geom_line(aes(y = fk), colour = 'dodgerblue4') + 
  ylab(' ') + xlab('Month/Year') + 
  geom_ribbon(aes(ymin=ci_lower, ymax=ci_upper), alpha=0.25, colour = 'grey40') + 
  scale_y_continuous(breaks = scales::pretty_breaks(10)) +
  scale_x_date(breaks = scales::pretty_breaks(8), date_labels = "%b/%Y") + 
  ggtitle('Smooth')

plot_grid(p1, p2, ncol=1)
```
Note that seasonality was included in using harmonic components which totals six parameters; for simplicity the results illustrated for this block of components concern the posterior distribution of their sum, whose mean and variance are given by

$$
\mu_{seasonality} = \mathbf{F}_{seasonality}^\top \mathbf{a}(-k)_{seasonality}, \\
\sigma_{seasonality} = \mathbf{F}_{seasonality}^\top \mathbf{R}(-k)_{seasonality} \mathbf{F}_{seasonality}
$$
where $\mathbf{a}(-k)_{seasonality}$ and $\mathbf{R}(-k)_{seasonality}$ are the
smoothed mean vector and the smoothed covariance of the posteriori distribution
for the seasonality components. $\mathbf{F}$ is the regression vector associated.

 

```{r, echo=FALSE, "components for airpassangers example"}
p1 = posteriori_smooth_df %>% filter(parameter == 'theta_1') %>% 
  posterior_plot + ggtitle('Component: Level', subtitle = 'deltrend = 0.95')
p2 = posteriori_smooth_df %>% filter(parameter == 'theta_2') %>% 
  posterior_plot + ggtitle('Component: Growth', subtitle = 'deltrend = 0.95')
p3 = posteriori_smooth_df %>% filter(parameter == 'theta_7') %>% 
  posterior_plot + ggtitle('Component: Seasonality', subtitle = 'deltrend = 0.98')

plot_grid(p1, p2, p3)
```

